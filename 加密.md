### [我们为什么需要加密](https://www.schneier.com/blog/archives/2015/06/why_we_encrypt.html)
  * ### 加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。这种保护是攸关我们每个人的。
  * ### 加密是我们所拥有的最强力的隐私保护技术，是唯一适合避免大规模监视。
  * ### 避免犯罪分子撒网寻找可乘之机——的技术。
  * ### 通过使用加密迫使双方都只能专注于具体的个体目标，我们也保护了这个社会。


### 加密算法
  * #### 对称加密(加密者和解密者用的秘钥都是一样的)
    * 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6
    * 举个简单例子，我把我的数据块切分成32位大小的，然后都和我的秘钥key(32位)进行异或，在相加，这就是个简单的对称加密了。。。有了我的key就可以解开了，在异或一次我的key就解开了
    * 举个例子AES的模式，有128，256 bit的，接下来是加密模式
      ECB：是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。
      CBC：是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。
      CFB/OFB实际上是一种反馈模式，目的也是增强破解的难度。
      还有填充方式，cbc是需要填充的， cbc还需要iv, 初始化向量

    > ECB和CBC的加密结果是不一样的，两者的模式不同，而且CBC会在第一个密码块运算时加入一个初始化向量。
  * #### 非对称加密(加密者和解密者使用的key是不同，就说加密者使用key1加密，解谜者使用key2解密)
    * 非对称加密算法RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用），有个公钥和私钥，公钥加密的数据只有对应的私钥能解开，而私钥加密的数据就只有公钥能解开了 ([rsa原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)),被破解的难度在于大整数的因式分解困难, rsa的加密明文是必须小于key的 [明文，密文长度](http://www.metsky.com/archives/657.html)而密文长度是和密钥长度是一致的。
    * 安全性 ECDH > DHE > RSA,DH, 前两者提供前向安全: 前向安全: 用来产生会话密钥(session key)的长期密钥(long-term key)泄露出去，不会造成之前通讯时使用的会话密钥(session key)的泄露，也就不会暴漏以前的通讯内容。简单的说，当你丢了这个long-term key之后，你以后的行为的安全性无法保证，但是你之前的行为是保证安全的
    * rsa加密时注意项, 跟DES，AES一样，RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。 当明文长度不够加密的长度时需要补足, 因为一次加密的长度是有固定的，为什么是固定的请看rsa原理篇
      RSA加密常用的填充方式有下面3种：

      1. RSA_PKCS1_PADDING 填充模式，最常用的模式，当你选择RSA_PKCS1_PADDING填充模式时，如果你的明文不够128字节， 加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。
      ```
      要求:
      输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11
      如果输入的明文过长，必须切割，　然后填充

      输出：和modulus一样长

      根据这个要求，对于512bit的密钥，　block length = 512/8 – 11 = 53 字节
      ```

      2. for RSA_NO_PADDING　　不填充，当你在客户端选择RSA_NO_PADDING填充模式时，如果你的明文不够128字节， 加密的时候会在你的明文前面，前向的填充零。解密后的明文也会包括前面填充的零，这是服务器需要注意把解密后的字段前向填充的零去掉，才是真正之前加密的明文
        ```
        输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充

        输出：和modulus一样长

        但跟AES等不同的是，　block length是跟key length有关的。

        每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是key length。
        ```
      2. RSA_PKCS1_OAEP_PADDING，RSA_PKCS1_OAEP_PADDING填充模式没有使用过， 他是PKCS#1推出的新的填充方式，安全性是最高的，和前面RSA_PKCS1_PADDING的区别就是加密前的编码方式不一样
      ```
      输入：RSA_size(rsa) – 41

      输出：和modulus一样长
      ```
      一句话不同的填充方式加解密也是不同的，使用的时候要注意

### ssl/tls的加密流程
[详见](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
### 数字证书
* [数字证书和数字签名的原理](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)
  简单来说数字签名就是传输信息的摘要，数字证书就是CA用自己的私钥把你的公钥及其他信息加密后生成内容, 即CA用自己的私钥来给你的公钥做数字签名
* 现在的数字证书一般采用证书的格式遵循 ITUT X.509国际标准。一个标准的X.509数字证书包含以下一些内容
  1. 证书的版本信息;
  2. 证书的序列号，每个证书都有一个唯一的证书序列号;
  3. 证书所使用的签名算法;
  4. 证书的发行机构名称，命名规则一般采用X.500格式;
  5. 证书的有效期，现在通用的证书一般采用UTC时间格式，它的计时范围为1950-2049;
  6. 证书所有人的名称，命名规则一般采用X.500格式;
  7. 证书所有人的公开密钥;
  8. 证书发行者对证书的签名。
  * ### 证书格式
    * PEM 格式

      PEM格式通常用于数字证书认证机构（Certificate Authorities，CA），扩展名为.pem, .crt, .cer, and .key。内容为Base64编码的ASCII码文件，有类似"-----BEGIN CERTIFICATE-----" 和 "-----END CERTIFICATE-----"的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为PEM格式（认证证书其实就是公钥）。Apache和类似的服务器使用PEM格式证书。

    * DER 格式
      
      DER格式与PEM不同之处在于其使用二进制而不是Base64编码的ASCII。扩展名为.der，但也经常使用.cer用作扩展名，所有类型的认证证书和私钥都可以存储为DER格式。Java是其典型使用平台。

    * PKCS#7/P7B 格式

      PKCS#7 或 P7B格式通常以Base64的格式存储，扩展名为.p7b 或 .p7c，有类似BEGIN PKCS7-----" 和 "-----END PKCS7-----"的头尾标记。PKCS#7 或 P7B只能存储认证证书或证书路径中的证书（就是存储认证证书链，本级，上级，到根级都存到一个文件中）。不能存储私钥，Windows和Tomcat都支持这种格式。

    * PKCS#12/PFX 格式

      PKCS#12 或 PFX格式是以加密的二进制形式存储服务器认证证书，中级认证证书和私钥。扩展名为.pfx 和 .p12，PXF通常用于Windows中导入导出认证证书和私钥。

* X.509证书标准支持三种不对称加密算法：RSA, DSA, Diffie-Hellman algorithms。最常用的是RSA算法

* 数字签名的作用
  1. 是能确定消息的不可抵赖性，因为他人假冒不了发送方的私钥签名。发送方是用自己的私钥对信息进行加密的，只有使用发送方的公钥才能解密。
  2. 是数字签名能保障消息的完整性。一次数字签名采用一个特定的哈希函数，它对不同文件产生的数字摘要的值也是不相同的
* 数字证书的作用
  1. 不可抵赖性
  2. 消息的完整性
  3. 身份认证

### CA 数字证书认证机构（英语：Certificate Authority，缩写为CA）
* 负责发放和管理数字证书的权威机构，承担公钥体系中公钥的合法性检验的责任。
* CA是证书的签发机构，它是PKI的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。
* CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。
* 如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。
* 如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的


### 公钥基础设施（Public Key Infrastructure，简称PKI）
[wiki](https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD)

参考: 
  1. [tsl/ssl进阶](https://segmentfault.com/a/1190000007283514)
  2. [ecdh, dh](http://www.cnblogs.com/fishou/p/4206451.html)
  3. [pki体系](http://blog.csdn.net/hherima/article/details/52469488)
  4. [ca证书链](http://www.jianshu.com/p/46e48bc517d0)